<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Lab 4: Javascript II</title>
	<link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="gold" /><text x="17" y="85" style="font: 600 60px/1 system-ui">JS</text></svg>' />
	<link href="talk.css" rel="stylesheet" />
	<script src="./talk.js" type="module"></script>
</head>
<body class="language-markup no-media" data-markdown-elements="details.notes, .md, .md-children > *">

<header id="intro" class="slide dont-resize">
	<h1>
		<div class="label">Lab 4</div>
		Javascript II
	</h1>
	<small>
		DSC 106: Data Visualization
		<!-- &bull; Slides by <a href="http://lea.verou.me">Lea Verou</a> -->
	</small>
</header>

<!-- <article class="slide columns force-1" id="npm">
	<header>
		<h1>What is <img src="images/npm-logo.svg" alt="npm">?</h1>
		<p class="subtitle">A <em>package manager</em> for JS</p>
	</header>
	<video src="videos/npm-install.mp4" loop autoplay muted></video>
	<details class="notes">
		A package manager is a tool that automates the process of installing, updating, configuring, and removing software.
		If you’ve written Python, you have likely used `pip`, its own package manager.
		You may have used package managers to install software in your operating system,
		such as`apt-get` or `brew`.
		They are command-line tools that allow you to install software from a central repository by simply referencing its name (and optionally a specific version).

		NPM stands for "Node Package Manager".
		It was originally created for Node.js, a JavaScript runtime that allows you to run JavaScript on the server.
		These days, NPM is used for much more than just Node.js, and is the most popular package manager for JavaScript.
		Most front-end developers use NPM to manage build tools and dependencies for their projects.

		Most NPM packages correspond to GitHub repos.
		When you install a package, NPM will download the package from the _NPM registry_ and install it in a directory called `node_modules`.
	</details>
</article> -->

<!-- <article class="slide columns force force-1">
	<h1>Anyone can publish a package!</h1>
	<img src="images/npm-anyone.png" alt="" class="browser">
</article>

<article class="slide md" id="npm-101" data-type="Cheatsheet">
	# npm 101

	- `package.json` A file containing metadata about a project
	- `node_modules/` A directory containing all the dependencies of a project
	- `npm install` Installs all dependencies listed in `package.json`
	- `npm install PACKAGE_NAME` Installs a package and adds it to `package.json`
	- `npm create PACKAGE_NAME` Create a new prpject, using another package as a template
	- `npm run SCRIPT_NAME` Runs a script defined in `package.json` (e.g. `build`, `dev`, etc.)
</article> -->

<!-- <article class="slide">
	<h1>Why use a JS Framework?</h1>
	<ol>
		<li>
			Developer Experience
			<ul class="delayed pros">
				<li>Declarative syntax</li>
				<li>Reactivity</li>
				<li>Modularity</li>
				<li>Convenience</li>
			</ul>
		</li>
	</ol>

	<details class="notes">
		There are many, *many* JS frameworks out there.
		The only reason to use a JS framework is development convenience.
		In theory, you could write everything in vanilla JS (as JS-without-frameworks is often called), but it would be a lot more work.
		However, development convenience can indirectly benefit end-users as well,
		because if you can develop faster, you can iterate faster, and deliver more features and bugfixes in the same amount of time.

		But how do JS frameworks provide development convenience?
		On a high level, in two ways:
		- **Declarativeness and reactivity**:
		Remember how we discussed that HTML and CSS are declarative and reactive, but JS is not?
		In CSS you declare what you want to happen, and it autoamtically takes care of the steps,
		whereas in JS, you have to specify every step.
		In CSS when a value changes (e.g. a CSS variable), everything that depends on it is automatically updated.
		JS frameworks expose a syntax that makes JS *declarative* and *reactive* as well.
		- **Modularity**:
		JS frameworks give us easier ways to break up the code of a large website or app into small, independent pieces that can be managed separately.
		This is achieved in many ways, such as components, data binding, etc.
	</details>
</article> -->

<!-- <article class="slide columns force-1" id="templating" data-credits="Wikipedia">
	<h1>Data binding</h1>
	<img src="images/templating.png" alt="">
</article>

<article class="slide columns force-3 code-labels" id="build-process">
	<h1>What is a build process?</h1>
	<section>
		<h2>index.md</h2>
		<pre class="language-markdown"><code>
			---
			title: Build Tools
			---

			# Build Process

			A build process reads *input files*
			and coverts them into *output files*.
		</code></pre>
	</section>
	<div class="arrow-right"></div>
	<section>
		<h2>index.html</h2>
		<pre class="language-html"><code>
			&lt;!DOCTYPE html>
			&lt;html>
			&lt;head>
				&lt;title>Build Tools&lt;/title>
			&lt;/head>
			&lt;body>
				&lt;h1>Build Process&lt;/h1>
				&lt;p>A build process reads &lt;em>input files&lt;/em>
				and coverts them into &lt;em>output files&lt;/em>.
			&lt;/body>
			&lt;/html>
		</code></pre>
	</section>
	<details class="notes">
		A build process is basically a compilation step that allows us to write code in a language other than those that the browser supports natively.
		It can do dramatic things like convert (*transpile*) a language that the browser doesn’t understand at all (e.g. TypeScript or CoffeeScript) to JavaScript,
		or lighter things like convert a language feature that the browser doesn’t understand yet (e.g. CSS nesting) to a version that it does understand.

		By convention, we run a website’s build process by running `npm run build`,
		which looks for a `build` key in the `scripts` part of `package.json`.
	</details>
</article> 

<article class="slide columns" id="modern-web-apps">
	<h1>Modern web apps</h1>
	<img src="images/components-1.png" alt="">
</article>

<article class="slide" id="also-modern-web-apps">
	<h1>Also modern web apps</h1>
</article>
-->
<!-- <article class="slide">
	<h1 class="md">HTML: `&lt;h1>` `&lt;ul>` `&lt;p>`</h1>
</article> -->

<article class="slide columns force" data-credits="https://www.componentdriven.org/" id="cdd">
	<h1>Component-driven development</h1>
	<img src="images/cdd.png" alt="">
</article>

<article class="slide">
	<h1>Traditional Architecture</h1>
	<div class="frame-by-frame">
		<img src="images/traditional-architecture-1.png" alt="">
		<img src="images/traditional-architecture-2.png" class="delayed" alt="">
		<img src="images/traditional-architecture-3.png" class="delayed" alt="">
	</div>
</article>

<!-- <article class="slide" id="cba">
	<h1>Component-based Architecture</h1>
	<div class="frame-by-frame">
		<img src="images/cb-architecture-1.png" alt="">
		<img src="images/cb-architecture-2.png" class="delayed" alt="">
		<img src="images/cb-architecture-3.png" class="delayed" alt="">
		<img src="images/cb-architecture-4.png" class="delayed" alt="">
	</div>
</article>

<article class="slide" id="cba">
	<h1>Component-based Architecture</h1>
	<div class="frame-by-frame">
		<img src="images/cb-architecture-1a.png" alt="">
		<img src="images/cb-architecture-2a.png" class="delayed" alt="">
		<img src="images/cb-architecture-3a.png" class="delayed" alt="">
		<img src="images/cb-architecture-4a.png" class="delayed" alt="">
		<img src="images/cb-architecture-4.png" class="delayed" alt="">
	</div> -->
</article>

<article class="slide columns force-1">
	<img src="images/soc-components.png" alt="">
	<details class="notes">
		Components give us a *different* separation of concerns than what we have seen so far
		(and arguably more pragmatic and scalable).
	</details>
</article>

<article class="slide" id="counter-component">
    <h1>Component-Driven Development in JS</h1>
    <div id="counter-container"></div>

    <script>
        class Counter {
            constructor(containerId) {
                this.count = 0;
                this.container = document.getElementById(containerId);

                // Create button
                this.button = document.createElement("button");
                this.button.textContent = `Count: ${this.count}`;
                
                // Add click event listener
                this.button.addEventListener("click", () => this.increment());

                // Append button to container
                this.container.appendChild(this.button);
            }

            // Increment counter and update button text
            increment() {
                this.count++;
                this.button.textContent = `Count: ${this.count}`;
            }
        }
        // Initialize the Counter component
        new Counter("counter-container");
    </script>
	<section>
		<pre class="delayed"><code>
			&lt;class Counter {
				constructor(containerId) {
					this.count = 0;
					this.container = document.getElementById(containerId);

					// Create button
					this.button = document.createElement("button");
					this.button.textContent = `Count: ${this.count}`;

					// Add click event listener
					this.button.addEventListener("click", () => this.increment());

					// Append button to container
					this.container.appendChild(this.button);
				}

				// Increment counter and update button text
				increment() {
					this.count++;
					this.button.textContent = `Count: ${this.count}`;
				}
			}

			// Initialize the Counter component
			new Counter("counter-container");
		</code></pre>
	</section>

	<pre class="delayed"><code>
        &lt;div id="counter-container">&lt;/div>
    </code></pre>

	<details class="notes">
        This example follows the **Component-Driven Development** pattern in Vanilla JavaScript.
        - The **Counter** class encapsulates both the UI and logic.
        - When the button is clicked, the count updates dynamically.
        - The component is **reusable**, meaning we can create multiple counters on the page.
    </details>
</article>

<!-- <article class="slide columns force dont-resize code-labels delayed-last" id="component-io">
	<h1>
		<span class="label">Components</span>
		Inputs and outputs
	</h1>

	<div>
		<pre class="syntax-breakdown language-jsx svelte no-trim"><code>
			&lt;ColorPicker <span title="Prop">format="oklch"</span>
				   <span title="Same as allowAlpha={true}">allowAlpha</span>
				   <span title="Map component data to context data" data-index="2">bind:color={ themeColor }</span>
				   <span title="Run saveThemeColor() when component fires a close event" data-index="2">on:close={ saveThemeColor }</span>>
				<span title="Component contents is is also an input" data-index="1">Theme color</span>
			&lt;/ColorPicker>
		</code></pre>

		<div class="browser">
			<color-swatch value="hsl(335 100% 50%)">Theme color</color-swatch>
		</div>
	</div>
	<img src="images/component-io.png" alt="">

	<details class="notes">
		Components are to UI what functions are to code.
		They have inputs, called *props*.
		Props look like HTML attributes, but can actually contain JS objects, arrays, etc.
		There is also another input: their contents.
		They are used to provide data and to parameterize the component.

		Often the only output of components is the UI they render.
		However, they can also have outputs, passed via *events*.
	</details>
</article> -->


<!-- 
<section>
	<header class="slide">
		<h1>Svelte (and SvelteKit)</h1>
	</header>

	<article class="slide">
		<h1>Why Svelte?</h1>

		<ul class="pros">
			<li>Performance</li>
			<li>Less client-side JS</li>
			<li>Easier syntax</li>
		</ul>
	</article>

	<article class="slide code-labels columns">
		<h1>Anatomy of a Svelte component</h1>
		<pre class="language-html svelte" style="--label: 'Component.svelte'"><code>
			&lt;script>
				// logic goes here
			&lt;/script>

			&lt;!-- HTML (zero or more elements) goes here

			&lt;style>
				/* Scoped CSS goes here */
			&lt;/style>
		</code></pre>
	</article>

	<article class="slide code-labels columns">
		<h1>Example Svelte component</h1>
		<section>
			<h2>Definition</h2>
			<pre class="language-html svelte" style="--label: 'Slider.svelte'"><code>
				&lt;script>
					// Define a prop "value"
					export let value = 50;
				&lt;/script>

				&lt;input type=range bind:value={value}>
				&lt;span>{ value }&lt;/span>

				&lt;style>
					span {
						display: inline-block;
						padding: 0 .4em;
						border-radius: .3em;
						background: oklch(95% 2% 200);
					}
				&lt;/style>
			</code></pre>
		</section>
		<section class="delayed">
			<h2>Usage</h2>
			<pre class="language-html svelte"><code>
				&LT;script>
					import Slider from './Slider.svelte';

					let myValue = 3;
				&LT;/script>

				&LT;Slider value={myValue}>&LT;/Slider>
			</code></pre>
			<div class="arrow-down"></div>
			<img src="images/slider.gif" alt="" class="browser" data-url="https://svelte.dev/repl/3ebeaec8826943e3a9deee0a1f0aedd2?version=4.2.12">
		</section>
		<details class="notes">
			[Live demo](https://svelte.dev/repl/3ebeaec8826943e3a9deee0a1f0aedd2?version=4.2.12)
		</details>
	</article>
</section>
 -->
<section>
	<article class="slide columns force-1">
		<h1>Reactivity</h1>
		<img src="images/spreadsheet.gif" alt="">
		<details class="notes">
			If you’ve used a spreadsheet, you already know what reactivity is.
			The core idea of reactivity is that when a value changes, all dependent values are updated automatically.
		</details>
	</article>

	<article class="minimal demo slide code-labels" id="css-reactive">
		<h1>CSS is reactive</h1>
		<textarea class="language-html">
			<label>
				Hue:
				<input type="range" max="360" id="hue"
					   oninput="document.body.style.setProperty('--hue', this.value)">
			</label>
		</textarea>
		<textarea class="language-css">
			body {
				--hue: 180;
				background: oklch(97% 5% var(--hue));
				accent-color: oklch(65% 55% var(--hue));
				color: oklch(40% 20% var(--hue));
			}
		</textarea>
		<div class="demo-target"></div>
		<details class="notes">
			As we have already seen, CSS is reactive.
			For example, if we update a CSS variable via JS, everything that depends on it (including other variables) is updated automatically.
		</details>
	</article>

	<article class="slide columns language-html code-labels">
		<h1>JS is not reactive</h1>

		<section>
			<pre class="language-css"><code>
				a:hover {
					background: gold;
				}
			</code></pre>
			<pre><code>
				&lt;a href="#">Come here&lt;/a>
			</code></pre>
			<div class="arrow-down"></div>
			<iframe data-result class="browser"></iframe>
		</section>

		<section>
			<pre><code>
				&lt;a href="#"
				   onmouseover="this.style.background = 'gold';"
				>Come here&lt;/a>
			</code></pre>
			<div class="arrow-down"></div>
			<iframe data-result class="browser"></iframe>
		</section>

		<section>
			<pre><code>
				&lt;a href="#"
				   onmouseover="this.style.background = 'gold';"
				   onmouseout="this.style.background = '';"
				>Come here&lt;/a>
			</code></pre>
			<div class="arrow-down"></div>
			<iframe data-result class="browser"></iframe>
		</section>
		<details class="notes">
			Remember this? As a part of CSS pseudo-classes are reactive:
			not only does the background here become `gold` when the link is hovered,
			but it also returns to its previous state automatically, when the link stops being hovered.

			However, when we use JS to do the same thing, we have to manually set the background back to its original value ourselves.
		</details>
	</article>

	<article class="slide" id="reactivity-hard">
		<h1>Implenting reactivity is <em>hard</em></h1>
		<form>
			<input type="number" id="input_a" value="1" oninput="input_c.value = Number(input_a.value) + Number(input_b.value)"> +
			<input type="number" id="input_b" value="2" oninput="input_c.value = Number(input_a.value) + Number(input_b.value)"> =
			<input type="number" id="input_c" value="3" disabled>
		</form>
		<pre class="delayed"><code>
			&lt;input type="number" id="input_a"> +
			&lt;input type="number" id="input_b"> =
			&lt;input type="number" id="input_c" disabled>
		</code></pre>
	</article>

	<article class="slide columns force-2 dont-resize language-js code-labels">
		<h1>Reactivity with vanilla JS</h1>
		<pre><code>
			let a = 1, b = 2, c;
			<span class="delayed">input_a.value = a;
			input_b.value = b;</span>

			<span class="delayed">input_a.addEventListener("input", e => {
				a = Number(input_a.value);
				<span class="delayed" data-index="3">updateC();</span>
			});
			input_b.addEventListener("input", e => {
				b = Number(input_b.value);
				<span class="delayed" data-index="3">updateC();</span>
			});</span>

			<span class="delayed" data-index="2">function updateC() {
				c = a + b;
				input_c.value = c;
			}</span>

			<span class="delayed" data-index="4">updateC();</span>
		</code></pre>
		<details class="notes">
			The naîve approach to implementing reactivity ourselves is to add event listeners to everything that could possibly change,
			and update everything that may have been affected.
			This gets very complicated very fast, since we need to keep track of all the dependencies and update them all manually.
			[Live demo](https://codepen.io/leaverou/pen/OJGMyvQ)
		</details>
	</article>

	<article class="slide columns force-2 language-js code-labels dont-resize">
		<h1>Reactivity with vanilla JS <span class="chip">Part 2</span></h1>
		<pre><code>
			let a = 1, b = 2, c;
			input_a.value = a;
			input_b.value = b;

			<span class="delayed">function render() {
				a = Number(input_a.value);
				b = Number(input_b.value);
				c = a + b;
				input_c.value = c;
			}</span>

			<span class="delayed">render();</span>
			<span class="delayed collapse">input_a.addEventListener("input", render);
			input_b.addEventListener("input", render);</span>
			<span class="delayed">document.body.addEventListener("input", render);</span>
		</code></pre>
		<details class="notes">
			Because this is so tedious, what we end up doing instead is is bunching updates together
			and updating more things than we need to, often everything at once with a single function.
			Then, every time anything updates, we call that single function and update *everything*.
			With that approach, we could even listen to the `input` event on an ancestor, since it [*bubbles*](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling),
			a practice known as [event delegation](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_delegation).

			However, the more complex the app, the slower this practice becomes, as we are updating more than we need to.
			Also, this makees it impossible to implement *two-way binding*, i.e. also update the input when the value changes, not just the other way around.

			[Live demo](https://codepen.io/leaverou/pen/OJGMydE)
		</details>
	</article>

	<article class="slide columns force-1">
		<h1>Reactivity boils down to <em>recalculation</em></h1>
		<img src="images/abc-dependency-graph.png" alt="">

		<details class="notes">
			There is one clear theme in both previous examples:
			Implementing reactivity boils down to recalculating things.
			The tricky bit is knowing *what* to recalculate and *when*.

			The what is typically implemented with a [*dependency graph*](https://en.wikipedia.org/wiki/Dependency_graph).
			When a value changes, we recalculate everything that depends on it, and everything that depends on those, and so on.
			The when is typically implemented with *events* when it’s about updating data from user actions,
			and [accessors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors) and [proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) when it's about updating the UI from data.
		</details>
	</article>
</section>

<article class="slide columns code-labels" id="web-apis">
	<h1>What is a Web API?</h1>
	<section>
		<h2>Websites are for humans</h2>
		<img src="images/yelp-restaurant.jpg" alt="">
	</section>
	<section>
		<h2>APIs are for programs</h2>
		<pre class="language-json"><code>
			{
				"id": "cuisine-of-nepal-san-francisco",
				"name": "Cuisine of Nepal",
				"image_url": ...,
				"is_closed": false,
				"url": ...,
				"review_count": 303,
				"categories": [...],
				"rating": 4.5,
				"coordinates": {...},
				"transactions": [
					"delivery",
					"pickup",
					"restaurant_reservation"
				],
				"price": "$$",
				"location": {...},
				"phone": "+14156472222",
				"display_phone": "(415) 647-2222",
				"distance": 2502.5961202999997,
				"attributes": {
					"gender_neutral_restrooms": true
				},
				"data": {
					"reservation_openings": [
						"13:30",
						"13:45",
						"14:00"
					]
				}
			},
		</code></pre>
	</section>
</article>

<article class="slide language-js xcode-labels">
	<h1>Async values</h1>
	<pre><code>
		let response = await fetch("https://api.github.com/users/giorgianicolaou");
		let json = await response.json();
		// Do stuff with json
	</code></pre>
	<pre><code>
		fetch("https://api.github.com/users/giorgianicolaou")
			.then(response => response.json())
			.then(json => {
				// Do stuff with json
			});
	</code></pre>
	<details class="notes">
		Many functions in JS cannot return a result within a reasonable amount of time.
		For example, [`fetch()`](https://developer.mozilla.org/en-US/docs/Web/API/fetch) sends an arbitrary HTTP request and reads the response. This can take a long time.
		To avoid blocking execution, we use *asynchronous* functions, which return a [*promise*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)
		which will eventually have the value we want.
		In fact, using `fetch()` involves two promises: one for the response, and one for the JSON data.
	</details>
</article>

<article class="slide code-labels">
	<h1>Using Async and Await</h1>
	<pre><code>
		async function fetchUserData() {
			try {
			  const response = await fetch("https://api.github.com/users/giorgianicolaou");
			  const user = await response.json();
			  console.log("User data:", user);
		  
			  const reposResponse = await fetch(user.repos_url);
			  const repos = await reposResponse.json();
			  console.log("Repositories:", repos);
			} catch (error) {
			  console.error("Error:", error);
			}
		  }
		  
		  fetchUserData();		  
	</code></pre>
</article>

<footer class="slide" id="end"></footer>

</body>
</html>