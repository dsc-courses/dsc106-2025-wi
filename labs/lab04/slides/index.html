<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Lab 4: Javascript II</title>
	<link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="gold" /><text x="17" y="85" style="font: 600 60px/1 system-ui">JS</text></svg>' />
	<link href="talk.css" rel="stylesheet" />
	<script src="./talk.js" type="module"></script>
</head>
<body class="language-markup no-media" data-markdown-elements="details.notes, .md, .md-children > *">

<header id="intro" class="slide dont-resize">
	<h1>
		<div class="label">Lab 4</div>
		Javascript II
	</h1>
	<small>
		DSC 106: Data Visualization
		<!-- &bull; Slides by <a href="http://lea.verou.me">Lea Verou</a> -->
	</small>
</header>

<!-- <article class="slide columns force-1" id="npm">
	<header>
		<h1>What is <img src="images/npm-logo.svg" alt="npm">?</h1>
		<p class="subtitle">A <em>package manager</em> for JS</p>
	</header>
	<video src="videos/npm-install.mp4" loop autoplay muted></video>
	<details class="notes">
		A package manager is a tool that automates the process of installing, updating, configuring, and removing software.
		If you‚Äôve written Python, you have likely used `pip`, its own package manager.
		You may have used package managers to install software in your operating system,
		such as`apt-get` or `brew`.
		They are command-line tools that allow you to install software from a central repository by simply referencing its name (and optionally a specific version).

		NPM stands for "Node Package Manager".
		It was originally created for Node.js, a JavaScript runtime that allows you to run JavaScript on the server.
		These days, NPM is used for much more than just Node.js, and is the most popular package manager for JavaScript.
		Most front-end developers use NPM to manage build tools and dependencies for their projects.

		Most NPM packages correspond to GitHub repos.
		When you install a package, NPM will download the package from the _NPM registry_ and install it in a directory called `node_modules`.
	</details>
</article> -->

<!-- <article class="slide columns force force-1">
	<h1>Anyone can publish a package!</h1>
	<img src="images/npm-anyone.png" alt="" class="browser">
</article>

<article class="slide md" id="npm-101" data-type="Cheatsheet">
	# npm 101

	- `package.json` A file containing metadata about a project
	- `node_modules/` A directory containing all the dependencies of a project
	- `npm install` Installs all dependencies listed in `package.json`
	- `npm install PACKAGE_NAME` Installs a package and adds it to `package.json`
	- `npm create PACKAGE_NAME` Create a new prpject, using another package as a template
	- `npm run SCRIPT_NAME` Runs a script defined in `package.json` (e.g. `build`, `dev`, etc.)
</article> -->

<!-- <article class="slide">
	<h1>Why use a JS Framework?</h1>
	<ol>
		<li>
			Developer Experience
			<ul class="delayed pros">
				<li>Declarative syntax</li>
				<li>Reactivity</li>
				<li>Modularity</li>
				<li>Convenience</li>
			</ul>
		</li>
	</ol>

	<details class="notes">
		There are many, *many* JS frameworks out there.
		The only reason to use a JS framework is development convenience.
		In theory, you could write everything in vanilla JS (as JS-without-frameworks is often called), but it would be a lot more work.
		However, development convenience can indirectly benefit end-users as well,
		because if you can develop faster, you can iterate faster, and deliver more features and bugfixes in the same amount of time.

		But how do JS frameworks provide development convenience?
		On a high level, in two ways:
		- **Declarativeness and reactivity**:
		Remember how we discussed that HTML and CSS are declarative and reactive, but JS is not?
		In CSS you declare what you want to happen, and it autoamtically takes care of the steps,
		whereas in JS, you have to specify every step.
		In CSS when a value changes (e.g. a CSS variable), everything that depends on it is automatically updated.
		JS frameworks expose a syntax that makes JS *declarative* and *reactive* as well.
		- **Modularity**:
		JS frameworks give us easier ways to break up the code of a large website or app into small, independent pieces that can be managed separately.
		This is achieved in many ways, such as components, data binding, etc.
	</details>
</article> -->

<!-- <article class="slide columns force-1" id="templating" data-credits="Wikipedia">
	<h1>Data binding</h1>
	<img src="images/templating.png" alt="">
</article>

<article class="slide columns force-3 code-labels" id="build-process">
	<h1>What is a build process?</h1>
	<section>
		<h2>index.md</h2>
		<pre class="language-markdown"><code>
			---
			title: Build Tools
			---

			# Build Process

			A build process reads *input files*
			and coverts them into *output files*.
		</code></pre>
	</section>
	<div class="arrow-right"></div>
	<section>
		<h2>index.html</h2>
		<pre class="language-html"><code>
			&lt;!DOCTYPE html>
			&lt;html>
			&lt;head>
				&lt;title>Build Tools&lt;/title>
			&lt;/head>
			&lt;body>
				&lt;h1>Build Process&lt;/h1>
				&lt;p>A build process reads &lt;em>input files&lt;/em>
				and coverts them into &lt;em>output files&lt;/em>.
			&lt;/body>
			&lt;/html>
		</code></pre>
	</section>
	<details class="notes">
		A build process is basically a compilation step that allows us to write code in a language other than those that the browser supports natively.
		It can do dramatic things like convert (*transpile*) a language that the browser doesn‚Äôt understand at all (e.g. TypeScript or CoffeeScript) to JavaScript,
		or lighter things like convert a language feature that the browser doesn‚Äôt understand yet (e.g. CSS nesting) to a version that it does understand.

		By convention, we run a website‚Äôs build process by running `npm run build`,
		which looks for a `build` key in the `scripts` part of `package.json`.
	</details>
</article> 

<article class="slide columns" id="modern-web-apps">
	<h1>Modern web apps</h1>
	<img src="images/components-1.png" alt="">
</article>

<article class="slide" id="also-modern-web-apps">
	<h1>Also modern web apps</h1>
</article>
-->
<!-- <article class="slide">
	<h1 class="md">HTML: `&lt;h1>` `&lt;ul>` `&lt;p>`</h1>
</article> -->

<article class="slide columns force" data-credits="https://www.componentdriven.org/" id="cdd">
	<h1>Component-driven development</h1>
	<img src="images/cdd.png" alt="">
</article>

<article class="slide">
	<h1>Traditional Architecture</h1>
	<div class="frame-by-frame">
		<img src="images/traditional-architecture-1.png" alt="">
		<img src="images/traditional-architecture-2.png" class="delayed" alt="">
		<img src="images/traditional-architecture-3.png" class="delayed" alt="">
	</div>
</article>

<!-- <article class="slide" id="cba">
	<h1>Component-based Architecture</h1>
	<div class="frame-by-frame">
		<img src="images/cb-architecture-1.png" alt="">
		<img src="images/cb-architecture-2.png" class="delayed" alt="">
		<img src="images/cb-architecture-3.png" class="delayed" alt="">
		<img src="images/cb-architecture-4.png" class="delayed" alt="">
	</div>
</article>

<article class="slide" id="cba">
	<h1>Component-based Architecture</h1>
	<div class="frame-by-frame">
		<img src="images/cb-architecture-1a.png" alt="">
		<img src="images/cb-architecture-2a.png" class="delayed" alt="">
		<img src="images/cb-architecture-3a.png" class="delayed" alt="">
		<img src="images/cb-architecture-4a.png" class="delayed" alt="">
		<img src="images/cb-architecture-4.png" class="delayed" alt="">
	</div> -->
</article>

<article class="slide columns force-1">
	<img src="images/soc-components.png" alt="">
	<details class="notes">
		Components give us a *different* separation of concerns than what we have seen so far
		(and arguably more pragmatic and scalable).
	</details>
</article>

<article class="slide columns force-2 dont-resize language-js code-labels">
    <h1>Basic Example Structure in JavaScript Modules</h1>
    
    <pre><code>
        <span class="delayed">üìÇ File Structure:
        index.html
        main.js
        modules/
            canvas.js
            square.js</span>

        <span class="delayed" data-index="2">üìå canvas.js ‚Äî Handles Canvas Setup
        function create(parent, width, height, id) {
            let wrapper = document.createElement("div");
            wrapper.id = id;
            let canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            wrapper.appendChild(canvas);
            parent.appendChild(wrapper);
            return { context: canvas.getContext("2d"), id };
        }

        function createReportList(wrapperId) {
            let list = document.createElement("ul");
            document.getElementById(wrapperId).appendChild(list);
            return list.id;
        }</span>

        <span class="delayed" data-index="3">üìå square.js ‚Äî Handles Square Operations
        const name = "square";

        function draw(context, x, y, size, color) {
            context.fillStyle = color;
            context.fillRect(x, y, size, size);
            return { size, x, y, color };
        }

        function reportArea(listId, length) {
            let list = document.getElementById(listId);
            let item = document.createElement("li");
            item.textContent = `Square area: ${length * length}`;
            list.appendChild(item);
        }

        function reportPerimeter(listId, length) {
            let list = document.getElementById(listId);
            let item = document.createElement("li");
            item.textContent = `Square perimeter: ${length * 4}`;
            list.appendChild(item);
        }</span>

        <span class="delayed" data-index="4">üìå main.js ‚Äî Bringing It All Together
        import { create, createReportList } from "./modules/canvas.js";
        import { draw, reportArea, reportPerimeter } from "./modules/square.js";

        const parent = document.body;
        const { context, id } = create(parent, 400, 400, "canvas-wrapper");
        const listId = createReportList(id);

        let square = draw(context, 50, 50, 100, "blue");
        reportArea(listId, square.size);
        reportPerimeter(listId, square.size);</span>
    </code></pre>

    <details class="notes">
        This slide explains the basic modular file structure of a JavaScript project. 
        - `canvas.js` handles canvas setup and creates report lists.
        - `square.js` handles drawing squares and calculating their area/perimeter.
        - `main.js` brings it all together by importing functions and executing them.
        This modular approach improves maintainability, readability, and reusability.
    </details>
</article>

<article class="slide columns force-2 dont-resize language-js code-labels">
    <h1>Exporting Module Features in JavaScript</h1>
    
    <pre><code>
        <span class="delayed">üìå Exporting Individual Features
        export const name = "square";

        export function draw(ctx, length, x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, length, length);
            return { length, x, y, color };
        }</span>

        <span class="delayed" data-index="2">‚úÖ You can export:
        - Functions
        - Variables (var, let, const)
        - Classes (not inside a function)</span>

        <span class="delayed" data-index="3">‚ùå Exporting inside a function is not allowed
        function example() {
            export const invalid = "Can't export here"; ‚ùå This would throw an error
        }</span>

        <span class="delayed" data-index="4">üìå Exporting Multiple Features at Once
        function reportArea(length) {
            return `Square area: ${length * length}`;
        }

        function reportPerimeter(length) {
            return `Square perimeter: ${length * 4}`;
        }

        export { name, draw, reportArea, reportPerimeter };</span>
    </code></pre>

    <details class="notes">
        To use JavaScript modules, we **export** features from a module file using the `export` statement.
        - You can **export each feature individually** (`export function draw(...)`).
        - You can **export multiple features at once** using `{}` at the end of a file.
        - Exports must be **top-level** (not inside functions).
    </details>
</article>

<article class="slide columns force-2 dont-resize language-js code-labels">
    <h1>Renaming Imports and Exports in JavaScript</h1>

    <pre><code>
        <span class="delayed">                   üìå Renaming Exports in a Module
                           inside module.js
                           export { function1 as newFunctionName, function2 as anotherNewFunctionName };</span>

        <span class="delayed" data-index="2">                   üìå Renaming Imports in main.js
                           import { newFunctionName, anotherNewFunctionName } from "./modules/module.js";</span>

        <span class="delayed" data-index="3">                   ‚úÖ Alternative Way: Renaming During Import
                           inside module.js
                           export { function1, function2 };

                           inside main.js
                           import { function1 as newFunctionName, function2 as anotherNewFunctionName } from "./modules/module.js";</span>

        <span class="delayed" data-index="4">                   üìå Handling Name Collisions Across Multiple Modules
                           Importing without renaming would cause a conflict
                           import { name, draw, reportArea, reportPerimeter } from "./modules/square.js";
                           import { name, draw, reportArea, reportPerimeter } from "./modules/circle.js"; ‚ùå Error: Redeclaration
                           import { name, draw, reportArea, reportPerimeter } from "./modules/triangle.js"; ‚ùå Error: Redeclaration</span>

        <span class="delayed" data-index="5">                   ‚úÖ Correct Approach: Rename Imports to Avoid Conflicts
                           import { 
                               name as squareName, draw as drawSquare, 
                               reportArea as reportSquareArea, reportPerimeter as reportSquarePerimeter 
                           } from "./modules/square.js";
  
                           import { 
                               name as circleName, draw as drawCircle, 
                               reportArea as reportCircleArea, reportPerimeter as reportCirclePerimeter 
                           } from "./modules/circle.js";

                           import { 
                               name as triangleName, draw as drawTriangle, 
                               reportArea as reportTriangleArea, reportPerimeter as reportTrianglePerimeter 
                           } from "./modules/triangle.js";</span>

        <span class="delayed" data-index="6">                   üìå Alternative: Renaming at the Export Level
                           in square.js
                           export { 
                               name as squareName, draw as drawSquare, 
                               reportArea as reportSquareArea, reportPerimeter as reportSquarePerimeter 
                           };

                           in main.js (No need for renaming now)
                           import { squareName, drawSquare, reportSquareArea, 
			                   reportSquarePerimeter } from "./modules/square.js";</span>
    </code></pre>

    <details class="notes">
        Renaming imports and exports is useful to **avoid naming conflicts** when working with multiple modules.
        - You can rename exports **inside the module** (`export { function1 as newFunctionName }`).
        - You can rename **during import** (`import { function1 as newFunctionName }`).
        - The best approach is usually to **rename during import**, as it avoids modifying the module code, which is useful when importing third-party modules.
    </details>
</article>


<article class="slide columns force-2 dont-resize language-js code-labels">
    <h1>Creating a Module Object in JavaScript</h1>

    <pre><code>
        <span class="delayed">üìå Importing Everything as a Module Object
        import * as Module from "./modules/module.js";</span>

        <span class="delayed" data-index="2">‚úÖ Now, you can access functions as object properties
        Module.function1();
        Module.function2();</span>

        <span class="delayed" data-index="3">üìå Applying This to a Real Example
        Exports in each module remain simple
        export { name, draw, reportArea, reportPerimeter };</span>

        <span class="delayed" data-index="4">üìå Importing Multiple Modules as Objects
        import * as Canvas from "./modules/canvas.js";
        import * as Square from "./modules/square.js";
        import * as Circle from "./modules/circle.js";
        import * as Triangle from "./modules/triangle.js";</span>

        <span class="delayed" data-index="5">‚úÖ Now, use the module's functions under its namespace
        const square1 = Square.draw(myCanvas.ctx, 50, 50, 100, "blue");
        Square.reportArea(square1.length, reportList);
        Square.reportPerimeter(square1.length, reportList);</span>
    </code></pre>

    <details class="notes">
        Instead of importing multiple functions individually, we can **import an entire module as an object**.
        - This keeps our imports **cleaner** and **more structured**.
        - Instead of calling `draw()`, we now use `Square.draw()`‚Äîthis **prevents name conflicts**.
        - This approach is useful when handling **multiple related modules** in a project.
    </details>
</article>

<article class="slide columns force-2 dont-resize language-js code-labels">
    <h1>Modules and Classes in JavaScript</h1>

    <pre><code>
        <span class="delayed">üìå Defining a Class in a Module (square.js)
        class Square {
            constructor(ctx, listId, length, x, y, color) {
                this.ctx = ctx;
                this.listId = listId;
                this.length = length;
                this.x = x;
                this.y = y;
                this.color = color;
            }

            draw() {
                this.ctx.fillStyle = this.color;
                this.ctx.fillRect(this.x, this.y, this.length, this.length);
            }

            reportArea() {
                console.log(`Square area: ${this.length * this.length}`);
            }

            reportPerimeter() {
                console.log(`Square perimeter: ${this.length * 4}`);
            }
        }</span>

        <span class="delayed" data-index="2">üìå Exporting the Class
        export { Square };</span>

        <span class="delayed" data-index="3">üìå Importing the Class in main.js
        import { Square } from "./modules/square.js";</span>

        <span class="delayed" data-index="4">‚úÖ Using the Class to Create and Draw a Square
        const square1 = new Square(myCanvas.ctx, myCanvas.listId, 50, 50, 100, "blue");
        square1.draw();
        square1.reportArea();
        square1.reportPerimeter();</span>
    </code></pre>

    <details class="notes">
        Instead of exporting individual functions, we can **use ES6 classes** inside modules.
        - This approach is useful when working in an **object-oriented** style.
        - The `Square` class encapsulates **both state and behavior** related to a square.
        - By importing `Square`, we can create multiple instances, making our code **more reusable**.
    </details>
</article>


<article class="slide columns force-2 dont-resize language-js code-labels">
    <h1>Aggregating Modules in JavaScript</h1>

    <pre><code>
        <span class="delayed">üìå Aggregating Modules Using Export
        export * from "x.js";
        export { name } from "x.js";</span>

        <span class="delayed" data-index="2">üìå Example: Module Structure
        modules/
            canvas.js
            shapes.js
            shapes/
                circle.js
                square.js
                triangle.js</span>

        <span class="delayed" data-index="3">üìå Exporting from Individual Submodules
        In square.js, circle.js, and triangle.js:
        export { Square };
        export { Circle };
        export { Triangle };</span>

        <span class="delayed" data-index="4">üìå Aggregating Modules in shapes.js
        export { Square } from "./shapes/square.js";
        export { Triangle } from "./shapes/triangle.js";
        export { Circle } from "./shapes/circle.js";</span>

        <span class="delayed" data-index="5">‚úÖ Using the Aggregated Module in main.js
        Before (multiple imports)
        import { Square } from "./modules/square.js";
        import { Circle } from "./modules/circle.js";
        import { Triangle } from "./modules/triangle.js";

        After (single import)
        import { Square, Circle, Triangle } from "./modules/shapes.js";</span>
    </code></pre>

    <details class="notes">
        Instead of importing multiple submodules separately, we can **aggregate them** into a single parent module.
        - `shapes.js` acts as a **wrapper** that re-exports everything from `square.js`, `circle.js`, and `triangle.js`.
        - This keeps our **imports cleaner** and **reduces complexity**.
        - The exports in `shapes.js` are **redirects** and cannot contain additional logic.
    </details>
</article>

<article class="slide columns force-2 dont-resize language-js code-labels">
    <h1>Dynamic Module Loading in JavaScript</h1>

    <pre><code>
        <span class="delayed">üìå Dynamically Importing a Module
        import("./modules/myModule.js").then((module) => {
            Do something with the module.
        });</span>

        <span class="delayed" data-index="2">‚úÖ Dynamic Imports are Useful for:
        - Loading modules only when needed (performance boost)
        - Keeping initial script lightweight
        - Importing in non-module scripts
        - Avoiding unnecessary network requests</span>

        <span class="delayed" data-index="3">üìå Example: Loading Modules on Button Click
        Get reference to button
        const squareBtn = document.querySelector(".square");

        Attach event listener for dynamic import
        squareBtn.addEventListener("click", () => {
            import("./modules/square.js").then((Module) => {
                const square1 = new Module.Square(
                    myCanvas.ctx, myCanvas.listId, 50, 50, 100, "blue"
                );
                square1.draw();
                square1.reportArea();
                square1.reportPerimeter();
            });
        });</span>

        <span class="delayed" data-index="4">‚úÖ Why Use Dynamic Imports?
        - Modules are only loaded when needed (e.g., button click)
        - Reduces initial load time of the webpage
        - Prevents loading unused code</span>
    </code></pre>

    <details class="notes">
        Dynamic module loading allows JavaScript to **import modules on demand**, improving performance by **loading only what is needed**.
        - The `import()` function **returns a Promise** that resolves with a module object.
        - Dynamic imports **work even in non-module scripts**, unlike static `import` statements.
        - This technique is useful for **lazy loading features**, **reducing network requests**, and **keeping code modular**.
    </details>
</article>


<!-- <article class="slide columns force dont-resize code-labels delayed-last" id="component-io">
	<h1>
		<span class="label">Components</span>
		Inputs and outputs
	</h1>

	<div>
		<pre class="syntax-breakdown language-jsx svelte no-trim"><code>
			&lt;ColorPicker <span title="Prop">format="oklch"</span>
				   <span title="Same as allowAlpha={true}">allowAlpha</span>
				   <span title="Map component data to context data" data-index="2">bind:color={ themeColor }</span>
				   <span title="Run saveThemeColor() when component fires a close event" data-index="2">on:close={ saveThemeColor }</span>>
				<span title="Component contents is is also an input" data-index="1">Theme color</span>
			&lt;/ColorPicker>
		</code></pre>

		<div class="browser">
			<color-swatch value="hsl(335 100% 50%)">Theme color</color-swatch>
		</div>
	</div>
	<img src="images/component-io.png" alt="">

	<details class="notes">
		Components are to UI what functions are to code.
		They have inputs, called *props*.
		Props look like HTML attributes, but can actually contain JS objects, arrays, etc.
		There is also another input: their contents.
		They are used to provide data and to parameterize the component.

		Often the only output of components is the UI they render.
		However, they can also have outputs, passed via *events*.
	</details>
</article> -->


<!-- 
<section>
	<header class="slide">
		<h1>Svelte (and SvelteKit)</h1>
	</header>

	<article class="slide">
		<h1>Why Svelte?</h1>

		<ul class="pros">
			<li>Performance</li>
			<li>Less client-side JS</li>
			<li>Easier syntax</li>
		</ul>
	</article>

	<article class="slide code-labels columns">
		<h1>Anatomy of a Svelte component</h1>
		<pre class="language-html svelte" style="--label: 'Component.svelte'"><code>
			&lt;script>
				// logic goes here
			&lt;/script>

			&lt;!-- HTML (zero or more elements) goes here

			&lt;style>
				/* Scoped CSS goes here */
			&lt;/style>
		</code></pre>
	</article>

	<article class="slide code-labels columns">
		<h1>Example Svelte component</h1>
		<section>
			<h2>Definition</h2>
			<pre class="language-html svelte" style="--label: 'Slider.svelte'"><code>
				&lt;script>
					// Define a prop "value"
					export let value = 50;
				&lt;/script>

				&lt;input type=range bind:value={value}>
				&lt;span>{ value }&lt;/span>

				&lt;style>
					span {
						display: inline-block;
						padding: 0 .4em;
						border-radius: .3em;
						background: oklch(95% 2% 200);
					}
				&lt;/style>
			</code></pre>
		</section>
		<section class="delayed">
			<h2>Usage</h2>
			<pre class="language-html svelte"><code>
				&LT;script>
					import Slider from './Slider.svelte';

					let myValue = 3;
				&LT;/script>

				&LT;Slider value={myValue}>&LT;/Slider>
			</code></pre>
			<div class="arrow-down"></div>
			<img src="images/slider.gif" alt="" class="browser" data-url="https://svelte.dev/repl/3ebeaec8826943e3a9deee0a1f0aedd2?version=4.2.12">
		</section>
		<details class="notes">
			[Live demo](https://svelte.dev/repl/3ebeaec8826943e3a9deee0a1f0aedd2?version=4.2.12)
		</details>
	</article>
</section>
 -->
<section>
	<article class="slide columns force-1">
		<h1>Reactivity</h1>
		<img src="images/spreadsheet.gif" alt="">
		<details class="notes">
			If you‚Äôve used a spreadsheet, you already know what reactivity is.
			The core idea of reactivity is that when a value changes, all dependent values are updated automatically.
		</details>
	</article>

	<article class="minimal demo slide code-labels" id="css-reactive">
		<h1>CSS is reactive</h1>
		<textarea class="language-html">
			<label>
				Hue:
				<input type="range" max="360" id="hue"
					   oninput="document.body.style.setProperty('--hue', this.value)">
			</label>
		</textarea>
		<textarea class="language-css">
			body {
				--hue: 180;
				background: oklch(97% 5% var(--hue));
				accent-color: oklch(65% 55% var(--hue));
				color: oklch(40% 20% var(--hue));
			}
		</textarea>
		<div class="demo-target"></div>
		<details class="notes">
			As we have already seen, CSS is reactive.
			For example, if we update a CSS variable via JS, everything that depends on it (including other variables) is updated automatically.
		</details>
	</article>

	<article class="slide columns language-html code-labels">
		<h1>JS is not reactive</h1>

		<section>
			<pre class="language-css"><code>
				a:hover {
					background: gold;
				}
			</code></pre>
			<pre><code>
				&lt;a href="#">Come here&lt;/a>
			</code></pre>
			<div class="arrow-down"></div>
			<iframe data-result class="browser"></iframe>
		</section>

		<section>
			<pre><code>
				&lt;a href="#"
				   onmouseover="this.style.background = 'gold';"
				>Come here&lt;/a>
			</code></pre>
			<div class="arrow-down"></div>
			<iframe data-result class="browser"></iframe>
		</section>

		<section>
			<pre><code>
				&lt;a href="#"
				   onmouseover="this.style.background = 'gold';"
				   onmouseout="this.style.background = '';"
				>Come here&lt;/a>
			</code></pre>
			<div class="arrow-down"></div>
			<iframe data-result class="browser"></iframe>
		</section>
		<details class="notes">
			Remember this? As a part of CSS pseudo-classes are reactive:
			not only does the background here become `gold` when the link is hovered,
			but it also returns to its previous state automatically, when the link stops being hovered.

			However, when we use JS to do the same thing, we have to manually set the background back to its original value ourselves.
		</details>
	</article>

	<article class="slide" id="reactivity-hard">
		<h1>Implenting reactivity is <em>hard</em></h1>
		<form>
			<input type="number" id="input_a" value="1" oninput="input_c.value = Number(input_a.value) + Number(input_b.value)"> +
			<input type="number" id="input_b" value="2" oninput="input_c.value = Number(input_a.value) + Number(input_b.value)"> =
			<input type="number" id="input_c" value="3" disabled>
		</form>
		<pre class="delayed"><code>
			&lt;input type="number" id="input_a"> +
			&lt;input type="number" id="input_b"> =
			&lt;input type="number" id="input_c" disabled>
		</code></pre>
	</article>

	<article class="slide columns force-2 dont-resize language-js code-labels">
		<h1>Reactivity with vanilla JS</h1>
		<pre><code>
			let a = 1, b = 2, c;
			<span class="delayed">input_a.value = a;
			input_b.value = b;</span>

			<span class="delayed">input_a.addEventListener("input", e => {
				a = Number(input_a.value);
				<span class="delayed" data-index="3">updateC();</span>
			});
			input_b.addEventListener("input", e => {
				b = Number(input_b.value);
				<span class="delayed" data-index="3">updateC();</span>
			});</span>

			<span class="delayed" data-index="2">function updateC() {
				c = a + b;
				input_c.value = c;
			}</span>

			<span class="delayed" data-index="4">updateC();</span>
		</code></pre>
		<details class="notes">
			The na√Æve approach to implementing reactivity ourselves is to add event listeners to everything that could possibly change,
			and update everything that may have been affected.
			This gets very complicated very fast, since we need to keep track of all the dependencies and update them all manually.
			[Live demo](https://codepen.io/leaverou/pen/OJGMyvQ)
		</details>
	</article>

	<article class="slide columns force-2 language-js code-labels dont-resize">
		<h1>Reactivity with vanilla JS <span class="chip">Part 2</span></h1>
		<pre><code>
			let a = 1, b = 2, c;
			input_a.value = a;
			input_b.value = b;

			<span class="delayed">function render() {
				a = Number(input_a.value);
				b = Number(input_b.value);
				c = a + b;
				input_c.value = c;
			}</span>

			<span class="delayed">render();</span>
			<span class="delayed collapse">input_a.addEventListener("input", render);
			input_b.addEventListener("input", render);</span>
			<span class="delayed">document.body.addEventListener("input", render);</span>
		</code></pre>
		<details class="notes">
			Because this is so tedious, what we end up doing instead is is bunching updates together
			and updating more things than we need to, often everything at once with a single function.
			Then, every time anything updates, we call that single function and update *everything*.
			With that approach, we could even listen to the `input` event on an ancestor, since it [*bubbles*](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling),
			a practice known as [event delegation](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_delegation).

			However, the more complex the app, the slower this practice becomes, as we are updating more than we need to.
			Also, this makees it impossible to implement *two-way binding*, i.e. also update the input when the value changes, not just the other way around.

			[Live demo](https://codepen.io/leaverou/pen/OJGMydE)
		</details>
	</article>

	<article class="slide columns force-1">
		<h1>Reactivity boils down to <em>recalculation</em></h1>
		<img src="images/abc-dependency-graph.png" alt="">

		<details class="notes">
			There is one clear theme in both previous examples:
			Implementing reactivity boils down to recalculating things.
			The tricky bit is knowing *what* to recalculate and *when*.

			The what is typically implemented with a [*dependency graph*](https://en.wikipedia.org/wiki/Dependency_graph).
			When a value changes, we recalculate everything that depends on it, and everything that depends on those, and so on.
			The when is typically implemented with *events* when it‚Äôs about updating data from user actions,
			and [accessors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors) and [proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) when it's about updating the UI from data.
		</details>
	</article>
</section>

<article class="slide columns code-labels" id="web-apis">
	<h1>What is a Web API?</h1>
	<section>
		<h2>Websites are for humans</h2>
		<img src="images/yelp-restaurant.jpg" alt="">
	</section>
	<section>
		<h2>APIs are for programs</h2>
		<pre class="language-json"><code>
			{
				"id": "cuisine-of-nepal-san-francisco",
				"name": "Cuisine of Nepal",
				"image_url": ...,
				"is_closed": false,
				"url": ...,
				"review_count": 303,
				"categories": [...],
				"rating": 4.5,
				"coordinates": {...},
				"transactions": [
					"delivery",
					"pickup",
					"restaurant_reservation"
				],
				"price": "$$",
				"location": {...},
				"phone": "+14156472222",
				"display_phone": "(415) 647-2222",
				"distance": 2502.5961202999997,
				"attributes": {
					"gender_neutral_restrooms": true
				},
				"data": {
					"reservation_openings": [
						"13:30",
						"13:45",
						"14:00"
					]
				}
			},
		</code></pre>
	</section>
</article>

<article class="slide language-js xcode-labels">
	<h1>Async values</h1>
	<pre><code>
		let response = await fetch("https://api.github.com/users/giorgianicolaou");
		let json = await response.json();
		// Do stuff with json
	</code></pre>
	<pre><code>
		fetch("https://api.github.com/users/giorgianicolaou")
			.then(response => response.json())
			.then(json => {
				// Do stuff with json
			});
	</code></pre>
	<details class="notes">
		Many functions in JS cannot return a result within a reasonable amount of time.
		For example, [`fetch()`](https://developer.mozilla.org/en-US/docs/Web/API/fetch) sends an arbitrary HTTP request and reads the response. This can take a long time.
		To avoid blocking execution, we use *asynchronous* functions, which return a [*promise*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)
		which will eventually have the value we want.
		In fact, using `fetch()` involves two promises: one for the response, and one for the JSON data.
	</details>
</article>

<article class="slide code-labels">
	<h1>Using Async and Await</h1>
	<pre><code>
		async function fetchUserData() {
			try {
			  const response = await fetch("https://api.github.com/users/giorgianicolaou");
			  const user = await response.json();
			  console.log("User data:", user);
		  
			  const reposResponse = await fetch(user.repos_url);
			  const repos = await reposResponse.json();
			  console.log("Repositories:", repos);
			} catch (error) {
			  console.error("Error:", error);
			}
		  }
		  
		  fetchUserData();		  
	</code></pre>
</article>

<footer class="slide" id="end"></footer>

</body>
</html>